
[
{
"JVM의 구조와 Java의 실행방식을 설명": "자바 가상 머신의 약자를 따서 줄여 부르는 용어로 JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것입니다. 메모리 관리(GC)을 수행하며 스택기반의 가상머신입니다. JVM의 구조는 Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있습니다. 클래스 로더는 JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈입니다. 실행 엔진은 바이트 코드를 실행시키는 역할을 합니다. 인터프리터는 바이트 코드를 한줄 씩 실행하며, JIT 컴파일러는 인터프리터 효율을 높이기 위한 컴파일러입니다. GC(Garbage Collector)는 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 의미합니다. Runtime Data Areas는 프로그램 실행 중에 사용되는 다양한 영역으로 PC Register는 현재 수행 중인 JVM 명령의 주소를 갖고 있으며, Stack Area는 지역 변수와 파라미터가 생성되는 영역입니다. Heap Area는 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC의 대상 영역입니다. Method Area는 클래스 멤버 변수와 메소드 정보 등이 생성되는 영역입니다. JNI(Java Native Interface)는 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공하며, Native Method Library는 C, C++로 작성된 라이브러리입니다. Java의 실행방식은 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시키고, Class Loader를 통해 class 파일들을 JVM으로 로딩하며, Execution engine을 통해 해석된 바이트코드가 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다."
},
{
"GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명": "GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총칭합니다. 이 객체를 제거하는 작업이 필요한 이유는 자바는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문입니다. GC의 동작방식은 가장 간단한 Serial GC 방식으로 설명합니다. 좀 더 진보된 GC는 G1 GC, ZGC가 있으며 여기선 다루지 않습니다. GC는 Minor GC, Major GC로 구분할 수 있습니다. Minor GC는 young 영역에서, Major GC는 old 영역에서 일어난다고 정의합니다. Minor GC는 Eden 영역이 가득 참에서 시작되며, Eden 영역에서 참조가 남아있는 객체를 mark하고 survivor 영역으로 복사합니다. 그리고 Eden 영역을 비웁니다. Survivor 영역도 가득차면 같은 방식으로 다른 Survivor 영역에 복사하고 비웁니다. 이를 반복하다 보면 계속해서 살아남는 객체는 old 영역으로 이동하게 됩니다. Major GC는 old 영역에서 일어나며, 삭제되어야 하는 객체를 mark하고 sweep합니다. 메모리는 단편화된 상태이므로 compact라고 하는 작업을 통해 한 군데에 모아줍니다. 이 과정을 Mark-Sweep-Compact 알고리즘이라고 합니다. GC 수행시 시스템이 멈추기 때문에 의도치 않은 장애의 원인이 될 수 있으며, 이를 위해 힙 영역을 조정하는 것을 GC 튜닝이라고 합니다. JVM 메모리는 절대 마음대로 조정해선 안됩니다."
},
{
"컬렉션 프레임워크에 대해서 설명": "Java Collection은 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 합니다. List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는 별도로 정의됩니다."
},
{
"제네릭에 대해서 설명": "제네릭은 자바의 타입 안정성을 맡고 있으며, 컴파일 과정에서 타입체크를 해주는 기능으로 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다."
},
{
"애노테이션에 대해서 설명": "애노테이션은 인터페이스를 기반으로 한 문법으로, 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션이 대표적인 예입니다. 메타 애너테이션은 애노테이션을 선언할 때 사용하는 애노테이션으로 @Retention, @Inherit, @Target이 있습니다."
},
{
"오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?": "오버라이딩은 상위 클래스의 메소드를 재정의하는 것을 의미하며, 런타임 다형성이기도 합니다. 오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며, 컴파일 타임 다형성이기도 합니다. 따라서 오버라이딩은 동일한 시그니처의 메소드를 하위 클래스에서 재정의할 수 있습니다."
},
{
"인터페이스와 추상클래스의 차이점에 대해 설명": "추상클래스는 객체의 추상적인 상위 개념을 표현할 때 사용하며, 단일 상속만 가능합니다. 인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하며, 다중 상속이 가능합니다. 추상클래스를 상속하는 클래스 간에는 연관관계가 있지만, 인터페이스를 구현하는 클래스 간에는 관계가 없을 수 있습니다."
},
{
"클래스는 무엇이고 객체는 무엇인가요?": "클래스는 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용됩니다. 객체는 식별 가능한 사람, 물건, 장소, 개념이나 사건 등의 개념을 구체화한 것입니다. 즉, 클래스는 데이터와 메소드의 집합을 의미하며, 객체는 클래스의 인스턴스로서의 의미입니다."
},
{
"Call by Value와 Call by Reference의 차이에 대해 설명": "Call by Value는 값에 의한 호출로 매개변수에 실제 값을 전달하는 것을 의미합니다. 즉, 메소드가 값을 복사하여 이용하고 호출 시에 값을 전달합니다. Call by Reference는 참조에 의한 호출로 매개변수에 객체의 주소(참조값)를 전달하는 것을 의미합니다. 즉, 메소드가 객체의 주소를 참조하여 이용하고, 호출 시에 주소를 전달합니다."
},
{
"동기화와 비동기화의 차이점을 설명": "동기화는 작업을 진행하는 동안 다른 작업이 끝날 때까지 대기하고 있는 것을 의미합니다. 이렇게 하나의 작업이 끝날 때까지 다른 작업이 대기하는 상태를 동기화라고 합니다. 비동기화는 작업을 진행하는 동안 다른 작업을 기다리지 않고 다른 작업을 진행할 수 있습니다. 이러한 비동기화는 함수를 실행할때 함수가 호출할수있다."
},
{
  "자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?": "실제 면접에서 들었던 질문입니다. 들었을 때 굉장히 당황했던 기억이 나네요. boolean(1), char(unsigned 2), byte(1), short(2), int(4), long(8), float(4), double(8) 사실 JVM에 의존적이기 때문에 정확한 크기라기 보다는 대략적인 크기입니다."
},
{
  "접근 제어자의 종류와 이에 대해 설명": "private, default, protected, public이 있습니다. private은 해당 클래스 내에서만 접근 가능하고, default는 해당 패키지, protected는 상속한 클래스, public은 전체 영역에서 접근 가능합니다. 접근 제어자를 사용하는 이유는 외부에 보여주고 싶은 정보들을 선택적으로 제공하기 위함이고, 캡슐화와 통하는 면이 있습니다."
},
{
  "객체지향에 대해서 설명": "객체지향을 정의하면, 의존성 관리입니다. 객체지향으로 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능해집니다. 따라서 객체지향에서 가장 중요한 것은 DIP(Dependency Inversion Principle)를 통한 고수준 정책(High Level Policy)와 저수준 구현 세부사항(Low Level Details)의 분리라고 할 수 있습니다."
},
{
  "SOLID(객체지향 5대원칙)에 대해서 설명": "SRP(단일책임원칙)은 한 클래스의 하나의 책임만 가져야 합니다. OCP(개방-폐쇄 원칙)은 확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 합니다. LSP(리스코프 치환 원칙)은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙으로 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지지 않아야 합니다. ISP(인터페이스 분리 원칙)은 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫습니다. 즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다. DIP(의존관계 역전 원칙)은 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙입니다. 구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙입니다."
},
{
  "동일성(identity)와 동등성(equality)에 대해 설명 (equals(), ==)": "동일성은 객체의 주소를 비교하는 것이고, 동등성은 객체의 같음을 비교하는 것입니다. 기본적으로 자바에서는 Object 클래스에 정의된 equals() 메소드가 동일성 비교를 합니다. 따라서, 개발자는 원한다면 equals() 메소드를 오버라이딩해서 동등성의 판단 기준을 정의해주면 됩니다."
},
{
  "원시타입과 참조타입의 차이에 대해 설명": "원시타입은 Java에서 단 8개 밖에 존재하지 않는 타입입니다. 나머지는 모두 참조타입이라고 볼 수 있고, Object 클래스이거나 이를 상속하는 클래스들로 이루어져 있습니다. 원시타입은 항상 값이 존재해야 합니다. 반면, Object 타입은 null 포인터를 가질 수 있습니다. 그리고 멤버변수가 초기화될 때, 원시타입은 기본값을 가지지만, 참조타입은 null 포인터를 가지는 차이도 있습니다."
},
{
  "String, StringBuilder, StringBuffer 각각의 차이에 대해 설명": "String은 불변입니다. StringBuilder와 StringBuffer는 이런 String의 특징때문에 사용하는 가변타입이라고 볼 수 있습니다. StringBuilder와 StringBuffer는 Thread-safe 여부의 차이가 있습니다. StringBuilder는 Thread-safe하지 않습니다. 따라서 Multi-Thread 환경에서 사용할 때는 StringBuffer를 사용합니다."
},
{
  "Checked Exception과 Unchecked Exception에 대해 설명 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?": "둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException이 됩니다. 스프링 트랜잭션 추상화에서 rollback 대상은 바로 UncheckedException입니다. 이 둘을 잘 알기 위해서는 토비의 스프링을 보시는 것을 추천합니다."
},
{
  "Java8에서 추가된 기능에 대해서 설명": "자신이 사용한 경험을 말해주면 더 효과적일 것 같습니다. Java8에서는 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다. lambda는 함수형 프로그래밍을 지원하기 위한 기능이고, Stream API는 고차함수를 지원합니다. Optional은 Null-safety를 제공하며, Stream과 사용법이 유사합니다. 날짜 시간 API는 Joda-time등의 라이브러리에서 영향을 받아 괜찮은 API가 되었으며, StringJoiner는 문자열을 간단하게 구분자로 합칠 수 있는 기능을 제공합니다."
},
{
  "try-with-resource에 대해서 설명": "try-with-resources는 자바 버전7에 도입된 문법입니다. 자바 7 버전 이전에서 하나 이상의 리소스(java.lang.AutoCloseable을 구현한 객체 혹은 java.io.Closeable를 구현한 객체)를 사용할 경우 개발자가 임의로 finally 문에서 ~~.close()를 사용하여 자원 해제를 시켜줘야 했습니다. 만약 개발자가 사용한 자원을 finally 문에서 해제시켜주지 않고 누락시켰다면 자원이 해제되지 않은 채로 프로그램이 오작동하게 되고, finally 문에서 자원을 해제 시켜주더라도 자원 해제를 위한 중복 코드가 발생하기 때문에 소스 코드의 가독성을 해치는 단점이 있었습니다. 이러한 문제점을 해결하기 위해 자바 7 버전에 try-with-resources가 도입되었습니다. try-with-resources는 try(...) 형태로 작성되며, 괄호 안에 자원을 선언할 수 있습니다. try-with-resources 문을 실행하면 try 블록이 종료될 때 자동으로 자원을 해제시킵니다. 이 때, 자원이 AutoCloseable을 구현한 경우 close() 메서드가 자동으로 호출되고, 자원이 AutoCloseable을 구현하지 않고, Closeable을 구현한 경우도 close() 메서드가 자동으로 호출됩니다. try-with-resources 문을 사용하여 자원 해제를 수행하면 finally 문에서 자원 해제를 수행하는 중복 코드가 사라지고, 자원 해제를 누락시키는 문제도 방지할 수 있습니다. try-with-resources는 자바 7 버전 이후에 도입된 문법이며, 자원 해제를 자동으로 수행하는 기능을 제공합니다."
},
{
  "Optional 클래스에 대해서 설명": "Optional 클래스는 자바 8에 추가된 클래스입니다. null-safe한 프로그래밍을 지원하기 위해 만들어졌습니다. null 체크를 명시적으로 하지 않고도 null 값을 처리할 수 있게 해줍니다. 즉, null을 직접 다루는 것보다 Optional 클래스를 사용하여 코드의 가독성을 높일 수 있습니다. Optional 객체는 값이 있을 수도 있고, 없을 수도 있는 값을 감싸고 있습니다. 따라서 Optional 객체는 값을 포함하거나 비어있을 수 있습니다. 값이 있을 경우 get() 메서드를 사용하여 값을 가져올 수 있고, 값이 없을 경우 orElse() 메서드를 사용하여 기본 값을 설정할 수 있습니다. Optional 클래스의 사용 예시는 아래와 같습니다. Optional<String> opt = Optional.ofNullable(str); String value = opt.orElse(\"default value\"); 위 코드는 str 값이 null이 아닐 경우 str 값을 가져오고, str 값이 null일 경우 \"default value\"를 가져옵니다."
},
{
  "자바에서 Garbage Collection에 대해서 설명": "자바에서 Garbage Collection(GC)은 메모리 관리를 자동으로 수행하는 기능입니다. GC는 프로그램에서 더 이상 사용하지 않는 메모리를 탐지하고 해제하여 프로그램이 더 이상 메모리를 손으로 관리하지 않아도 되게 합니다. 자바의 GC는 JVM(JAVA Virtual Machine)에 의해 수행됩니다. JVM은 GC를 수행하여 사용되지 않는 객체를 메모리에서 제거하고, 제거된 메모리를 재사용할 수 있게 합니다. GC는 프로그램의 성능을 개선하고 메모리 누수를 방지하는 데 도움을 줍니다. GC의 동작 원리는 크게 두 가지 방법이 있습니다. 첫째, GC는 더 이상 사용하지 않는 객체를 탐지하여 메모리에서 제거합니다. GC는 객체가 언제 사용되지 않는지를 추적하고, 사용되지 않는 객체를 제거합니다. GC는 참조 카운트 방식 또는 추적 방식으로 사용되지 않는 객체를 탐지할 수 있습니다. 둘째, GC는 제거된 메모리를 재사용하여 다시 사용할 수 있습니다. GC는 사용되지 않는 메모리를 재사용하여 다시 사용할 수 있습니다. GC는 메모리 관리를 자동으로 수행하여 개발자가 메모리 관리를 손으로 관리하지 않아도 되게 합니다. GC는 프로그램의 성능을 개선하고, 메모리 누수를 방지하는 데 도움을 줍니다."
},
{
  "자바에서 다형성에 대해 설명": "다형성은 한 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다. 자바에서는 다형성을 객체지향 프로그래밍의 한 가지 특징으로 제공하고 있습니다. 다형성을 사용하면 하나의 객체를 여러 가지 타입으로 사용할 수 있으며, 다양한 타입으로 사용할 수 있습니다. 자바에서 다형성을 구현하는 방법으로는 상속, 인터페이스, 메서드 오버라이딩, 메서드 오버로딩 등이 있습니다. 상속을 사용하여 하위 클래스가 상위 클래스의 메서드를 재정의할 수 있으며, 인터페이스를 사용하여 다양한 타입을 구현할 수 있습니다. 메서드 오버라이딩을 사용하여 하위 클래스가 상위 클래스의 메서드를 재정의할 수 있으며, 메서드 오버로딩을 사용하여 메서드의 이름이 같은 다양한 타입을 구현할 수 있습니다. 자바에서 다형성은 객체지향 프로그래밍의 한 가지 특징으로 제공하고 있으며, 다형성을 사용하여 하나의 객체를 여러 가지 타입으로 사용할 수 있으며, 다양한 타입으로 사용할 수 있습니다."
},
{
  "자바에서 추상 클래스와 인터페이스의 차이에 대해 설명": "추상 클래스와 인터페이스는 객체지향 프로그래밍에서 사용되는 두 가지 추상화 방법입니다. 추상 클래스는 추상 메서드와 일반 메서드를 포함할 수 있으며, 인터페이스는 추상 메서드만을 포함할 수 있습니다. 추상 클래스는 일반 클래스와 마찬가지로 필드, 생성자, 메서드 등을 포함할 수 있으며, 추상 메서드를 포함할 수도 있습니다. 추상 클래스는 객체를 생성할 수 없으며, 하위 클래스가 상속하여 사용할 수 있습니다. 인터페이스는 추상 메서드만을 포함할 수 있으며, 필드, 생성자, 메서드 등을 포함할 수 없습니다. 인터페이스는 상수와 추상 메서드만을 포함할 수 있으며, 하위 클래스가 구현하여 사용할 수 있습니다. 자바에서 추상 클래스와 인터페이스는 추상화 방법으로 사용되며, 추상 클래스와 인터페이스의 차이점을 이해하여 사용할 수 있습니다."
},
{
  "자바에서 스레드(Thread)와 프로세스(Process)의 차이에 대해 설명": "자바에서 스레드(Thread)와 프로세스(Process)는 동시성 프로그래밍에서 사용되는 개념입니다. 스레드(Thread)는 프로세스(Process) 내에서 실행되는 실행 흐름(Flow of control)입니다. 스레드는 프로세스의 자원을 공유하며, 동시에 여러 작업을 수행할 수 있습니다. 스레드는 단일 프로세스(Process) 내에서 실행되는 실행 흐름(Flow of control)입니다. 프로세스(Process)는 실행 중인 프로그램입니다. 프로세스는 운영 체제에 의해 관리되며, 프로세스는 자원을 할당받고, 스케줄링되어 실행됩니다. 프로세스는 운영 체제에 의해 관리되며, 프로세스는 운영 체제의 시스템 자원을 할당받고,프로세스는 운영 체제의 시스템 자원을 관리하고, 프로세스는 운영 체제의 시스템 자원을 사용할 수 있습니다. 자바에서 스레드(Thread)와 프로세스(Process)는 동시성 프로그래밍에서 사용되는 개념으로, 스레드는 프로세스의 자원을 공유하며, 동시에 여러 작업을 수행할 수 있습니다. 스레드는 단일 프로세스(Process) 내에서 실행되는 실행 흐름(Flow of control)입니다. 프로세스(Process)는 실행 중인 프로그램으로, 프로세스는 운영 체제에 의해 관리되며, 자원을 할당받고, 스케줄링되어 실행됩니다. 프로세스는 다양한 작업을 수행할 수 있습니다."
}


]