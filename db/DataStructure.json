[
{
"시간 복잡도를 계산": "시간 복잡도는 주어진 알고리즘의 수행 시간이 입력 크기에 따라 얼마나 늘어나는지를 나타내는 것입니다."
},
{
"배열과 링크드 리스트의 차이를 설명": "배열은 메모리에 순차적으로 데이터를 저장하며 인덱스로 접근할 수 있는 반면, 링크드 리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 연결되어 있어 삽입, 삭제가 용이합니다."
},
{
"List와 Set의 차이에 대해서 설명": "List는 중복된 데이터를 허용하고 순서를 유지하는 선형 자료구조이며, Set은 중복된 데이터를 허용하지 않고, 순서를 보장하지 않는 자료구조입니다."
},
{
"Hash Function, HashTable에 대해서 설명": "Hash Function은 임의 크기의 데이터를 고정된 크기의 데이터로 매핑하는 함수이며, HashTable은 키(key)와 값(value)을 해시 함수를 사용하여 매핑하여 저장하는 자료구조입니다."
},
{
"Stack, Queue에 대해서 설명": "Stack은 후입선출(LIFO, Last In First Out)의 원리로 동작하는 자료구조로, 주로 함수 호출이나 undo 메커니즘 등에 사용됩니다. Queue는 선입선출(FIFO, First In First Out)의 원리로 동작하는 자료구조로, 대기열 관리나 버퍼 처리 등에 사용됩니다."
},
{
"Heap, Priority Queue에 대해서 설명": "Heap은 완전 이진 트리의 일종으로, 최대값 또는 최소값을 빠르게 찾을 수 있는 자료구조입니다. Priority Queue는 Heap을 기반으로 하며, 우선순위가 높은 데이터를 먼저 처리하는 자료구조입니다."
},
{
"Tree, Binary Tree, BST, AVL Tree에 대해서 설명": "Tree는 계층적인 구조를 가지며, Binary Tree는 각 노드가 최대 두 개의 자식을 가지는 Tree입니다. BST는 Binary Tree 중에서 왼쪽 자식 노드는 항상 부모 노드보다 작고, 오른쪽 자식 노드는 항상 부모 노드보다 큰 특성을 가지는 Tree입니다. AVL Tree는 BST의 한 종류로, 균형을 맞추어 삽입, 삭제 연산 시 시간 복잡도를 개선한 Tree입니다."
},
{
"BST의 최악의 경우의 예와 시간복잡도에 대해서 설명": "BST가 아닌 Self-Balanced Tree(예: AVL Tree)를 사용하는 이유는, 특정한 순서로 데이터를 삽입하게 되면 BST는 선형 구조가 될 수 있고, 이 경우 탐색에 O(n)의 시간 복잡도가 발생할 수 있기 때문입니다."
},
{
"피보나치 수열을 코드로 구현하는 방법에 대해서 설명": "피보나치 수열은 재귀적인 방법으로 구현할 수 있지만, 중복 계산이 많아 성능이 떨어질 수 있습니다. 이를 개선하기 위해 DP(Dynamic Programming)를 사용하여 이전에 계산한 값을 저장하고 활용하는 방법이 있습니다."
},
{
"DFS, BFS에 대해서 설명": "DFS(Depth-First Search)는 깊이를 우선으로 탐색하는 그래프 탐색 알고리즘이며, BFS(Breadth-First Search)는 너비를 우선으로 탐색하는 알고리즘입니다. 각각의 사용 예시와 시간 복잡도에 대해서도 설명이 가능합니다."
},
{
"정렬, 탐색에 대해 설명": "정렬은 데이터를 특정 기준에 따라 순서대로 나열하는 작업이며, Bubble Sort, Quick Sort, Merge Sort 등의 알고리즘이 있습니다. 탐색은 주어진 데이터에서 특정 값을 찾는 작업이며, 이진 탐색(Binary Search) 등의 알고리즘이 있습니다."
}
]
