[
{
"Spring DI/IoC 동작 설명": "IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어집니다.  DI(의존관계 주입)은 Spring 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해줍니다.  스프링에서는 스프링 컨테이너 ApplicationContext를 이용하여 설정 정보를 생성, 등록하고 필요한 객체를 생성자 혹은 setter를 통해 주입합니다."
},
{
"Spring Bean 설명": "IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC컨테이너에서 가져와서 사용합니다. @Bean 을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할 수 있습니다."
},
{
"스프링 Bean의 생성 과정을 설명.": "객체 생성 → 의존 설정 → 초기화 → 사용 → 소멸 과정의 생명주기를 가지고 있습니다. Bean은 스프링 컨테이너에 의해 생명주기를 관리하며 빈 초기화방법은 @PostConstruct 를 빈 소멸에서는 @PreDestroy 를 사용합니다.  생성한 스프링 빈을 등록할 때는 ComponentScan을 이용하거나 @Configuration 의 @Bean 을 사용하여 빈 설정파일에 직접 빈을 등록할 수 있습니다."
},
{
"스프링 Bean의 Scope에 대해서 설명.": "빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며 싱글톤, 프로토타입, request, session, application 등이 있습니다.  싱글톤은 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프입니다.  프로토타입은 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프입니다.  request는 웹 요청이 들어오고 나갈때까지 유지하는 스코프, session은 웹 세션이 생성, 종료할때까지, application은 웹 서블릿 컨텍스트와 같은 범위로 유지하는 스코프입니다."
},
{
"IoC 컨테이너의 역할은 무엇이 있을까요?": "애플리케이션 실행시점에 빈 오브젝트를 인스턴스화하고 DI 한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공해준다"
},
{
"DI 종류는 어떤것이 있고, 이들의 차이 설명": "DI는 세가지 방법이 있습니다. 생성자 삽입, Setter를 이용한 메소드 매개 변수 삽입, 필드 주입이 있습니다.  생성자 주입은 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용합니다.  Setter주입은 선택, 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록이 가능합니다.  필드 주입은 `@Autowired` 를 사용하는데 외부에서 변경이 불가능하여 테스트 하기 힘듭니다. DI 프레임워크 없이는 작동하기 힘들며, 주로 애플리케이션과 관계없는 테스트코드나 `@Configuration` 같은 스프링 설정 목적으로 사용합니다."
},
{
"Autowiring 과정에 대해서 설명": "컨테이너에서 타입(인터페이스 또는 오브젝트)을 이용해 의존 대상 객체를 검색하고 할당할 수 있는 빈 객체를 찾아 주입한다"
},
{
"프론트 컨트롤러 패턴 설명": "클라이언트의 다양한 요청마다 서블릿을 만들어서 사용한다고 하면 개발과 유지보수의 효율이 떨어질 수 밖에 없습니다. 프론트 컨트롤러 패턴을 사용함으로써 각 요청을 적절한 곳으로 위임해줌으로써 개발과 유지보수의 효율성이 증가하고 모든 요청에 대해 보안, 국제화, 라우팅 및 로그와 같은 일반적인 기능을 한 곳에서 캡슐화할 수 있습니다. Spring에서는 DispatcherServlet이 프론트 컨트롤러 패턴을 사용한 예이며, DispatcherServlet이 Bean으로 등록되어 package를 scan하고 @Controller, @RestController 애노테이션을 확인하여 어떠한 요청이 들어왔을 때 적절한 Handler Method에 위임해줍니다."
},
{
"Servlet Filter와 Spring Interceptor의 차이 설명": "Filter는 Servlet Filter로써 javax.servlet 스펙에 포함되는 클래스입니다.  Interceptor는 Spring MVC 스펙에 포함되어 있는 클래스입니다.  Filter는 Servlet에서 전후처리를 담당하며, Interceptor는 Spring에서 Handler를 실행하기 전후나, ViewResolver를 통해 컨트롤러에서 리턴한 View Name으로부터 렌더링을 담당할 View 오브젝트를 준비해 돌려준 후 실제 View를 렌더링한 후에 어떠한 처리를 담당합니다.  Filter는 Web Application(Tomcat을 사용할 경우 web.xml)에 등록하며, Interceptor는 Spring의 Application Context에 등록합니다.  Filter는 Method Signature에 있는 Argument인 HttpServletRequest 혹은 HttpServeltResponse를 ServletRequest, ServletResponse 등으로 교체할 때 사용하거나, 데이터 변환(다운로드 파일의 압축 및 데이터 암호화 등), XSL/T를 이용한 XML 문서 변경, 사용자 인증, 자원 접근에 대한 로깅 등에 사용합니다.  Interceptor의 경우 AOP를 흉내내거나, Spring 애플리케이션에서 전역적으로 전후처리 로직에서 예외를 사용하도록 하거나, Handler Method에서 사용자의 권한을 체크해서 다른 동작을 시켜준다거나 할 때 사용합니다."
},
{
"Spring에서 CORS 에러를 해결하기 위한 방법을 설명": "Servlet Filter를 사용하여 커스텀한 Cors 설정하거나, WebMvcConfiguer를 구현한 Configuration 클래스를 만들어서 addCorsMappings()를 재정의할 수도 있고, 마지막으로 @CrossOrigin 애노테이션을 사용하여 Controller나 Handler Method에 명시적으로 선언할 수 있습니다."
},
{
"Spring에서 AOP(Aspect-Oriented Programming) 설명": "AOP는 관점 지향 프로그래밍으로, 애플리케이션 전반에 걸쳐 사용될 수 있는 기능을 재사용 가능한 모듈로 분리시키는 방법입니다. 특정 관점(Aspect)에서 주로 사용하는 여러 객체들에 분산되어 있는 코드를 한 곳으로 모으고, 코드의 중복성을 제거하며, 소스코드의 메소드 실행 시점에 타깃 객체의 메소드에 기능을 추가할 수 있습니다. AOP에서는 Advice(어드바이스), Joinpoint(조인포인트), Pointcut(포인트컷)이 중요한 개념입니다.  Advice는 실제 기능을 의미하며, Joinpoint는 Advice가 적용될 수 있는 위치(메소드 실행, 필드 수정 등)를 의미하며, Pointcut은 Joinpoint의 부분집합을 나타내는 표현식입니다. AOP는 주로 Logging, 트랜잭션 처리, 보안 검사 등에서 사용됩니다."
},
{
"Spring에서의 Aspect(관점) 설명": "관점(Aspect)은 여러 객체에 걸쳐 중복되어 나타나는 코드를 하나로 모아 재사용 가능한 모듈로 분리하는 방법입니다. Spring AOP에서는 Advice(어드바이스), Joinpoint(조인포인트), Pointcut(포인트컷)과 함께 사용됩니다. Advice는 실제 기능을 의미하며, Joinpoint는 Advice가 적용될 수 있는 위치(메소드 실행, 필드 수정 등)를 의미하며, Pointcut은 Joinpoint의 부분집합을 나타내는 표현식입니다."
},
{
"Spring에서의 AOP 프록시 설명": "Spring에서 AOP는 프록시를 이용해 동작합니다. Target 객체를 감싸는 프록시 객체를 만들어, Target 객체의 메소드 호출 전/후에 원하는 코드를 추가할 수 있습니다. Spring에서는 JDK 동적 프록시 또는 CGLIB 프록시를 생성해 AOP를 구현합니다.  1. JDK 동적 프록시는 인터페이스를 구현한 클래스에 대해 생성되며, 인터페이스가 없는 클래스에는 적용할 수 없습니다.   2. CGLIB 프록시는 클래스를 상속받은 서브클래스를 생성해 프록시를 구현하며, 인터페이스가 없어도 적용할 수 있습니다."
},
{
"Spring에서의 Transaction 관리 방법 설명": "Spring에서는 선언적 트랜잭션 관리 방법과 Programmatic 트랜잭션 관리 방법이 있습니다.  1. 선언적 트랜잭션 관리: @Transactional 애노테이션을 사용해 트랜잭션을 관리합니다. XML 기반의 설정으로도 사용할 수 있습니다.  2. Programmatic 트랜잭션 관리: TransactionTemplate이나 PlatformTransactionManager 인터페이스를 사용해 코드 내에서 직접 트랜잭션을 관리합니다."
},
{
"Spring Boot의 특징": "Spring Boot는 스프링 기반의 독립적인 실행 가능한 애플리케이션을 쉽게 만들 수 있도록 도와주는 프레임워크입니다. 주요 특징은 다음과 같습니다:  1. 자동 설정: Starter 패키지와 의존성을 추가하면 자동으로 설정이 이루어지며, XML 설정이 필요 없습니다.  2. 스타터 패키지: 특정 목적을 가진 의존성 집합으로서, 필요한 라이브러리들을 한 번에 추가할 수 있습니다.  3. 내장 서버: Tomcat, Jetty, Undertow와 같은 웹 서버를 내장하고 있어 별도의 배포 없이 실행 가능합니다.  4. 간편한 빌드 설정: Maven이나 Gradle을 사용해 손쉽게 빌드할 수 있습니다.  5. 강력한 관리 기능: Actuator를 통해 애플리케이션의 상태 모니터링 및 관리가 가능합니다."
},
{
"Spring Boot의 시작 방법": "Spring Initializr 웹 사이트를 통해 스프링 부트 프로젝트를 생성하거나, IDE에 있는 Spring Boot Starter Project를 이용해 프로젝트를 생성할 수 있습니다. 시작하기 위해 Maven이나 Gradle을 사용해 빌드 설정 파일을 생성한 후, 필요한 의존성을 추가합니다. 애플리케이션은 @SpringBootApplication 어노테이션이 붙은 메인 클래스에서 시작됩니다."
},
{
"Spring Boot에서의 외부 설정 방법": "Spring Boot는 application.properties 또는 application.yml 파일을 통해 외부 설정을 지원합니다. 자동 설정 기능을 이용해 설정 클래스를 작성할 필요 없이, properties나 yml 파일에 필요한 설정을 작성하면 됩니다. 또한, 프로파일을 이용해 여러 환경에서 다른 설정을 적용할 수 있습니다."
},
{
"Spring Boot Actuator는?": "Spring Boot Actuator는 스프링 부트 애플리케이션의 모니터링 및 관리를 위한 기능을 제공하는 모듈입니다. Actuator는 HTTP 엔드포인트를 통해 애플리케이션의 다양한 정보를 제공하며, 애플리케이션의 상태를 모니터링할 수 있습니다. 예를 들어, /health 엔드포인트를 통해 애플리케이션의 상태를 확인하거나, /metrics 엔드포인트를 통해 메모리 사용량, 스레드 풀 정보 등을 제공받을 수 있습니다."
},
{
"Spring Boot에서의 외부 데이터베이스 연동 방법": "Spring Boot는 JDBC를 통해 데이터베이스에 접근하거나, Spring Data JPA를 사용해 ORM 기술을 이용할 수 있습니다. application.properties나 application.yml 파일을 통해 데이터베이스 연결 정보를 설정하고, @Repository 어노테이션을 붙인 인터페이스를 통해 데이터베이스와 상호작용할 수 있습니다. 또한, Spring Boot Starter를 이용해 데이터베이스 종류에 맞는 의존성을 추가할 수 있습니다."
},
{
"Spring Boot에서의 RESTful API 개발 방법": "Spring Boot에서 RESTful API를 개발하기 위해서는 @RestController 어노테이션을 사용한 컨트롤러 클래스를 작성하고, @RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping 등의 어노테이션을 이용해 HTTP 요청 메서드와 URL 매핑을설정해야 합니다. 또한, HTTP 요청을 처리하고 JSON, XML 등의 데이터 포맷으로 응답할 수 있는 @RequestBody와 @ResponseBody 어노테이션을 사용할 수 있습니다."
}
]