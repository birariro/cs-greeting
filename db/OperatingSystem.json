[
{
  "프로세스와 스레드의 차이": "프로세스는 운영체제로부터 자원을 할당받지만, 스레드는 프로세스로부터 자원을 할당받고, 프로세스의 코드/데이터/힙영역을 공유하기 때문에 좀 더 효율적으로 통신할 수 있습니다.  또한 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠릅니다.  그리고, 스레드는 자원 공유로 인해 문제가 발생할 수 있으니 이를 염두에 둔 프로그래밍을 해야합니다."
},
{
  "컨텍스트 스위칭": "컨텍스트 스위칭은 한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법입니다.  인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작합니다.  이 때, CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다.  스레드와 프로세스의 동작방식이 약간 상이한데, 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다. "
},
{
  "스레드와 프로세스의 차이(Difference between Thread and Process)": "프로세스는 운영체제에서 실행 중인 프로그램을 나타내며 각 프로세스는 독립된 메모리 공간을 갖습니다.  반면에 스레드는 프로세스 내에서 실행되는 작업 단위로, 같은 프로세스 내의 다른 스레드들과 메모리 공간을 공유합니다.  즉, 프로세스는 독립적인 실행 단위이고, 스레드는 같은 프로세스 내에서 동작하며 리소스를 공유합니다. "
},
{
  "프로세스와 스레드의 차이를 설명": "프로세스는 실행중인 프로그램을 의미합니다. 스레드는 실행 제어만 분리한 것을 의미합니다. 프로세스는 운영체제로부터 자원을 할당받지만, 스레드는 프로세스로부터 자원을 할당받고, 프로세스의 코드/데이터/힙 영역을 공유하기 때문에 좀 더 효율적으로 통신할 수 있습니다. 또한 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠릅니다. 스레드는 자원 공유로 인해 문제가 발생할 수 있으니 이를 염두에 둔 프로그래밍을 해야합니다. 한 프로세스 안에 여러개의 스레드가 생성될 수 있습니다."
},
{
  "컨텍스트 스위칭에 대해 설명": "컨텍스트 스위칭은 한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법입니다. 인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작합니다. 이 때, CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다. 스레드와 프로세스의 동작 방식이 약간 상이한데, 스레드는 캐시 메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기 때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다."
},
{
  "동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명": "동기/비동기는 두 개 이상의 무엇인가가 시간을 맞춘다/안 맞춘다로 구분할 수 있습니다. 동기 방식은 메서드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식입니다. 또, 동기 방식은 한 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같습니다. 비동기 방식은 여러 개의 처리가 함께 실행되는 방식으로, 동기 방식에 비해 단위 시간 당 많은 작업을 처리할 수 있습니다. 단, CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있습니다. 프로그램의 복잡도도 증가하게 됩니다. 블로킹/논블로킹은 동기/비동기와는 다른 관점으로, 내가 직접 제어할 수 없는 대상(IO/멀티스레드)을 상대하는 방법에 대한 분류입니다. 블로킹 방식은 대상의 작업이 끝날 때까지 제어권을 대상이 가지고 있는 것을 의미합니다. 반면에 논블로킹은 대상의 작업 완료 여부와 상관없이 새로운 작업을 수행합니다. 동기 논블로킹은 계속해서 polling을 수행하기 때문에 컨텍스트 스위칭이 지속적으로 발생해 지연이 발생합니다."
},
{
  "멀티스레드 프로그래밍에 대해 설명": "멀티스레드 프로그래밍은 하나의 프로세스에서 여러 개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 의미합니다. 장점으로는 메모리 자원 소모가 줄어들며, 힙 영역을 통해 스레드 간 통신이 가능해 프로세스 간 통신보다 간단합니다. 또한, 스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 빠릅니다. 단점으로는 힙 영역에 있는 자원을 사용할 때 동기화가 필요하며, 동기화를 위해 락을 과도하게 사용하면 성능이 저하될 수 있고, 하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있습니다."
},
{
  "Thread-safe 하다는 의미와 설계하는 법을 설명": "두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산 결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미합니다. Thread-safe한 설계를 위해선 다음과 같은 방법을 사용합니다: java.util.concurrent 패키지 하위의 클래스를 사용, 인스턴스 변수를 두지 않음, Singleton 패턴을 사용(일반적으로 구현하는 Singleton Pattern은 Thread-safe하지 않음), 동기화(synchronized) 블럭에서 연산을 수행."
},
{
  "프로세스 동기화에 대해 설명": "프로세스 동기화는 다중 프로세스 환경에서 자원에 한 프로세스만 접근할 수 있도록 하는 것입니다. 프로세스 동기화를 하지 않으면 데이터의 일관성이 깨지기 때문에 연산 결과가 잘못 반환될 가능성이 존재합니다. Race Condition(경쟁 상태)은 공유된 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황을 의미합니다. Critical Section(임계 구역)은 여러 스레드가 동시에 접근해서는 안 되는 공유 자원에 접근하는 코드 블럭을 얘기합니다. 임계 구역에 접근하는 것을 제어하기 위해 세마포어, 뮤텍스와 같은 매커니즘을 사용합니다. 임계 구역 문제를 해결하기 위한 조건으로는 상호 배제(Mutual Exclusion), 진행(Progress), 유한 대기(Bounded Waiting) 조건을 모두 충족해야 합니다."
}

]