[
  {"데이터 베이스의 트렌젝션": "트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위라고 할 수 있으며, 트랜잭션에는 여러개의 연산이 수행될 수 있습니다. \\n트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다."},

  {"데이터베이스의 트렌젝션 격리수준": 
  "트랜잭션 격리수준은 고립도와 성능의 트레이드 오프를 조절합니다 \\n\\nREAD UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다. \\nREAD COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다. \\nREPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다. \\nSERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.(성능 매우 떨어짐)"},

  {"프로세스와 스레드의 차이": "프로세스는 운영체제로부터 자원을 할당받지만, \\n스레드는 프로세스로부터 자원을 할당받고, 프로세스의 코드/데이터/힙영역을 공유하기 때문에 좀 더 효율적으로 통신할 수 있습니다. \\n또한 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠릅니다. 그리고, 스레드는 자원 공유로 인해 문제가 발생할 수 있으니 이를 염두에 둔 프로그래밍을 해야합니다."},

  {"컨텍스트 스위칭":
  "컨텍스트 스위칭은 한 Task가 끝날 때까지 기다리는 것이 아니라 \n여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법입니다. \\n인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작합니다. 이 때, CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다. \\n스레드와 프로세스의 동작방식이 약간 상이한데, 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다."}
]